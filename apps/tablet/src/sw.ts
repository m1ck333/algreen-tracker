/// <reference lib="webworker" />
import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';

declare const self: ServiceWorkerGlobalScope;

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST);
cleanupOutdatedCaches();

// Push notification handler
self.addEventListener('push', (event) => {
  console.log('[SW] push event received', event.data ? 'with data' : 'no data');

  if (!event.data) return;

  let payload: { title: string; body: string; data?: Record<string, unknown> };
  try {
    payload = event.data.json();
    console.log('[SW] push payload:', JSON.stringify(payload));
  } catch {
    payload = { title: 'AlGreen MES', body: event.data.text() };
    console.log('[SW] push payload (text fallback):', payload.body);
  }

  event.waitUntil(
    self.registration.showNotification(payload.title, {
      body: payload.body,
      icon: '/pwa-192x192.png',
      badge: '/pwa-192x192.png',
      data: payload.data,
    } as NotificationOptions).then(
      () => console.log('[SW] showNotification succeeded'),
      (err) => console.error('[SW] showNotification failed:', err),
    ),
  );
});

// Click handler — focus or open the app
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const data = event.notification.data as Record<string, unknown> | undefined;
  console.log('[SW] notificationclick data:', JSON.stringify(data));

  let path = '/queue';
  if (data?.type === 'OrderActivated' || data?.type === 'ProcessReadyForQueue') {
    path = '/incoming';
  } else if (data?.type === 'DeadlineWarning' || data?.type === 'DeadlineCritical') {
    path = '/notifications';
  }

  // Build full URL from SW scope
  const url = new URL(path, self.location.origin).href;
  console.log('[SW] navigating to:', url);

  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clients) => {
      for (const client of clients) {
        if ('focus' in client) {
          return client.navigate(url).then(() => client.focus()).catch(async () => {
            // navigate() can fail on iOS — try postMessage first, then persist for visibilitychange
            try {
              client.postMessage({ type: 'navigate', url: path });
            } catch { /* ignore */ }
            // Persist path so the app can pick it up on visibilitychange (iOS fallback)
            const cache = await caches.open('sw-navigate');
            await cache.put('/_pending_navigate', new Response(path));
            return client.focus();
          });
        }
      }
      // No existing window — open a new one
      return self.clients.openWindow(url);
    }),
  );
});
